#***-------------------------------------------------------------------------------------------------***#
#*** AutoMated tool for Antimicrobial resistance Surveillance System version 2.0 (AMASS version 2.0) ***#
#***-------------------------------------------------------------------------------------------------***#
# Aim: to enable hospitals with microbiology data available in electronic formats
# to analyze their own data and generate Supplementary data indicators reports systematically.

# Created on 20th April 2022
import logging #for creating logfile
import pandas as pd #for creating and manipulating dataframe
import psutil,gc #for returning memory to system
import datetime #for setting date-time format
#from AMASS_amr_commonlib_annex_b import * #for importing data indicators functions
import AMASS_annex_b_commonlib as ALB
import AMASS_amr_const as AC
import AMASS_amr_commonlib as AL

def generate_annex_b(df_dict_micro,df_micro,logger,bisusingmappeddata,bisreload_micro):
    AL.printlog("Start Data Indicator (ANNEX B): " + str(datetime.datetime.now()),False,logger)
    path = AC.CONST_PATH_ROOT
    """
    i_micro  = path + "microbiology_data.xlsx"
    i_dict   = path + "dictionary_for_microbiology_data.xlsx"
    i_micro_csv  = path + "microbiology_data.csv"
    i_dict_csv   = path + "dictionary_for_microbiology_data.csv"
    """
    f_dict   = "dictionary_for_microbiology_data"
    f_micro  ="microbiology_data"
    f_micro_wide = "microbiology_data_reformatted"
    i_dataqc = path + "Configuration/list_of_indicators.xlsx"
    i_druglst= path + "Configuration/list_of_antibiotics.xlsx"
    
    o_list_withoutstatus = AC.CONST_PATH_REPORTWITH_PID + "Report_with_patient_identifiers_annexB.csv"
    o_list_withstatus = AC.CONST_PATH_REPORTWITH_PID + "Report_with_patient_identifiers_annexB_withstatus.csv"
    
    o_tab_blo = AC.CONST_PATH_RESULT + AC.CONST_FILENAME_secB_blo_i
    o_tab_blo_bymonth = AC.CONST_PATH_RESULT + AC.CONST_FILENAME_secB_blo_mon_i
    
    v2_o_tab_blo = AC.CONST_PATH_RESULT + AC.CONST_FILENAME_V2_secB_blo_i
    v2_o_tab_blo_bymonth = AC.CONST_PATH_RESULT + AC.CONST_FILENAME_V2_secB_blo_mon_i
    
    head_dict_1 = "Variable names used in AMASS"
    head_dict_2 = "Variable names used for \"antibiotics\" in AMASS"
    head_dict_3 = "Data values of variable used for \"specimen_type\" in AMASS"
    head_dict_4 = "Data values of variable \"organism\" in AMASS, which are mainly used for the main report"
    head_dict_5 = "Optional: Data values used for the cover of the report generated by AMASS"
    head_dict_6 = "Optional: Data values used for infection of origin  in AMASS "
    head_dict_7 = "Optional: Data values of variable used for \"organism\" in AMASS, which are mainly used for the annex"
    head_dict_8 = "Optional: Variables name used in AMASS; this is needed only when data is in long format"
    head_indi = "Please define the organism to be alerted and included in \"Supplementary: Data Indicator Report\""
    
    AL.printlog("ANNEX B Dictionary and configuration loading",False,logger)
    try:
        config = pd.read_excel(path + "Configuration/Configuration.xlsx")
    except:
        try:
            config = pd.read_csv(path + "Configuration/Configuration.csv")
        except:
            config = pd.read_csv(path + "Configuration/Configuration.csv", encoding="windows-1252")
    
    if ALB.check_config(config, "data_indicators_function"):
        lst_fam = []
        lst_sci = []
        lst_ge = []
        dict_micro = pd.DataFrame()
        datai = pd.DataFrame()
        micro_0 = pd.DataFrame()
        try:
            if (bisusingmappeddata == True) or (bisreload_micro == False):
                dict_micro = df_dict_micro.iloc[:,:2].fillna("")
            else:                   
                print("ANNEX B reload dict")
                dict_micro = AL.readxlsxorcsv(path, f_dict,logger).iloc[:,:2].fillna("")
                """
                try:
                    dict_micro = pd.read_excel(i_dict).iloc[:,:2].fillna("")
                except:
                    try:
                        dict_micro = pd.read_csv(i_dict_csv).iloc[:,:2].fillna("")
                    except:
                        dict_micro = pd.read_csv(i_dict_csv, encoding="windows-1252").iloc[:,:2].fillna("")
                """
            dict_micro.columns = ["amass_name","user_name"]
            dict_micro["amass_name"] = dict_micro["amass_name"].fillna("zzzz")
            hn      = AC.CONST_VARNAME_HOSPITALNUMBER
            spcdate = AC.CONST_VARNAME_SPECDATERAW
            CLEANSPECDATE = AC.CONST_NEWVARNAME_CLEANSPECDATE
            spctype = AC.CONST_VARNAME_SPECTYPE
            spcnum  = AC.CONST_VARNAME_SPECNUM
            organism= AC.CONST_VARNAME_ORG
            if bisusingmappeddata != True:
                hn      = ALB.retrieve_uservalue(dict_micro, "hospital_number")
                spcdate = ALB.retrieve_uservalue(dict_micro, "specimen_collection_date")
                spctype = ALB.retrieve_uservalue(dict_micro, "specimen_type")
                spcnum  = ALB.retrieve_uservalue(dict_micro, "specimen_number")
                organism= ALB.retrieve_uservalue(dict_micro, "organism")
            fmt     = ALB.retrieve_uservalue(dict_micro, "file_format")
            lst_no_growth   = ALB.retrieve_userlist(dict_micro,"organism_no_growth")
            lst_blood       = ALB.retrieve_userlist(dict_micro,"specimen_blood")
            lst_resistant   = ALB.retrieve_userlist(dict_micro,"resistant")
            lst_susceptible = ALB.retrieve_userlist(dict_micro,"susceptible")
            lst_intermediate= ALB.retrieve_userlist(dict_micro,"intermediate")
            lst_csf         = ALB.retrieve_userlist(dict_micro,"specimen_cerebrospinal_fluid")
            lst_spu         = ALB.retrieve_userlist(dict_micro,"specimen_respiratory_tract")
            lst_gen         = ALB.retrieve_userlist(dict_micro,"specimen_genital_swab")
            lst_uri         = ALB.retrieve_userlist(dict_micro,"specimen_urine")
            lst_sto         = ALB.retrieve_userlist(dict_micro,"specimen_stool")
            lst_oth         = ALB.retrieve_userlist(dict_micro,"specimen_others")
            #Retrieving all antibiotic list from dictionary_for_microbiology_data.xlsx
            idx_micro_drug = dict_micro.iloc[:,0].tolist().index(head_dict_2) #index of part2 header
            idx_micro_spc = dict_micro.iloc[:,0].tolist().index(head_dict_3) #index of part3 header
            idx_micro_org = dict_micro.iloc[:,0].tolist().index(head_dict_4) #index of part4 header
            dict_drug = dict_micro.copy().iloc[idx_micro_drug+1:idx_micro_spc,:2].reset_index().drop(columns=['index']).fillna("").rename(columns={"amass_name":"amass_drug","user_name":"user_drug"})
            #!!!This in case using df_micro that already map drug column to AMASS val if directly loaded please remove
            if bisusingmappeddata == True:
                dict_drug.loc[dict_drug["user_drug"].astype("string").str.len() >0, "user_drug"] = dict_drug["amass_drug"]
            #Merging antibiotic list among amass drug, amass class, user drug name
            try:
                df_drug = pd.read_excel(i_druglst).iloc[:,:2]
            except:
                try:
                    df_drug = pd.read_csv(path + "Configuration/list_of_antibiotics.csv").iloc[:,:2]
                except:
                    df_drug = pd.read_csv(path + "Configuration/list_of_antibiotics.csv", encoding="windows-1252").iloc[:,:2]
            df_drug.columns = ["amass_drug","amass_class"]
            df_drug = ALB.merge_drug_drugclass(drug_class= df_drug, 
                                        drug_user = dict_drug, 
                                        col_merge = "amass_drug")
            df_drug = ALB.create_new_drugcol(df          = df_drug, 
                                        col_drug    = "amass_drug", 
                                        col_drug_new= "amass_drug_rename")
            lst_cl = ALB.select_value(set(df_drug.loc[:,"amass_class"].tolist())) #list of available family
            lst_dr = ALB.select_value(set(df_drug.loc[:,"amass_drug"].tolist())) #list of available family
            
            dict_org_fam = ALB.retrieve_all_family(dict_micro) ##Retrieving all family
            dict_org_sci = ALB.retrieve_ava_scientific_name(dict_micro) ##Retrieving all organisms
            lst_fam = ALB.select_value(list(set(dict_org_fam["amass_name"].replace(regex=["family_"],value="")))) #list of available family
            lst_sci = ALB.select_value(list(set(dict_org_sci["amass_name"].replace(regex=["organism_"],value="").replace(regex=["_"],value=" ")))) #list of available org
            #For rule1
            lst_ge = ALB.select_value(list(set(dict_org_sci["amass_name"].replace(regex=["organism_"],value=""))))
            lst_ge = [i.split("_")[0] for i in lst_ge] #list of available genus
        except Exception as e:
            #logger.exception(e)
            AL.printlog("Error, ANNEX B Dictionary and configuration loading: " +  str(e),True,logger)
            pass
        ALB.sub_printprocmem("ANNEX B Dictionary and configuration loading",logger)
        AL.printlog("ANNEX B Data indicator loading",False,logger)
        try:
            #Retrieving verification rules from list_of_indicators.xlsx
            try:
                datai = pd.read_excel(i_dataqc)
            except:
                try:
                    datai = pd.read_csv(path + "Configuration/list_of_indicators.csv")
                except:
                    datai = pd.read_csv(path + "Configuration/list_of_indicators.csv", encoding="windows-1252")
            idx_part2 = datai.iloc[:,0].tolist().index(head_indi) #index of part2 header
            #data indicator part1
            d_datai_part1 = {}
            datai_part1 = datai.copy().iloc[:idx_part2,:2].reset_index().drop(columns=['index'])
            for idx in datai_part1.index:
                d_datai_part1[str(datai_part1.iloc[idx,0])] = datai_part1.iloc[idx,1]
            #data indicator part2
            datai_part2 = datai.copy().iloc[idx_part2+2:,:].reset_index().drop(columns=['index']).fillna("")
            col = datai_part2.columns
            datai_part2 = datai_part2.rename(columns={col[0]:"organism",col[1]:"antibiotic",col[2]:"rule_id", 
                                                    col[3]:"priority",col[4]:"report_status",col[5]:"reference"})
            #Assigning tax_level and user_drug
            
            datai_part2_1 = ALB.prepare_datai_org(df = datai_part2, 
                                            lst_fam = lst_fam,
                                            lst_ge = lst_ge,
                                            lst_sci = lst_sci,
                                            col_org = "organism")

            datai_part2_2 = ALB.prepare_datai_drug(df_datai = datai_part2_1, 
                                            df_drug  = df_drug, 
                                            col_drug = "antibiotic", 
                                            lst_drugclass = lst_cl, 
                                            lst_drugname  = lst_dr)

            datai_part2_export = datai_part2_2.copy().astype(str)
            datai_part2_2 = datai_part2_2.astype(str).loc[datai_part2_2["tax_level"] != "NA"] ##Selecting only available organism based on dictionary
            #Deleting noused dataframes
            del [[datai,datai_part2]]
            del lst_fam,lst_sci,lst_ge
            gc.collect()
            datai = pd.DataFrame()
            datai_part2 = pd.DataFrame()    
        except Exception as e:
            #logger.exception(e)
            AL.printlog("Error, ANNEX B Data indicator loading: " +  str(e),True,logger)
            pass  
        AL.printlog("ANNEX B microbiology_data file loading",False,logger)
        try:
            nogrowth_status = False
            if (bisusingmappeddata == True) or (bisreload_micro == False):
                micro_0 = df_micro.copy()
            else:
                if AL.checkxlsorcsv(path, f_micro_wide) == True:
                    print("ANNEX B reload micro wide format")
                    micro_0 = AL.readxlsxorcsv(path, f_micro_wide,logger).fillna("")
                else:
                    print("ANNEX B reload micro")
                    micro_0 = AL.readxlsxorcsv(path, f_micro,logger).fillna("")
            if (spcnum == "") or (spcnum not in micro_0.columns): #If there is no available specimen_nember column >>> create specimen_column from index
                micro_0["mapped_specimen_number"] = range(len(micro_0))
            else:
                pass
            #Reformat specimen date
            micro_0 = AL.fn_clean_date(micro_0, spcdate, CLEANSPECDATE, AC.CONST_CDATEFORMAT, logger)
            #Creating dataframe containing records with positive cultures
            d_blood = ALB.create_dict_for_map(lst_blood,"blood")
            d_no_growth = ALB.create_dict_for_map(lst_no_growth,"negative")
            d_allspc = dict(d_blood)
            d_allspc.update(ALB.create_dict_for_map(lst_csf,"csf"))
            d_allspc.update(ALB.create_dict_for_map(lst_spu,"rts"))
            d_allspc.update(ALB.create_dict_for_map(lst_gen,"genital swab"))
            d_allspc.update(ALB.create_dict_for_map(lst_sto,"stool"))
            d_allspc.update(ALB.create_dict_for_map(lst_uri,"urine"))
            d_allspc.update(ALB.create_dict_for_map(lst_oth,"others"))
            d_ast = {} #dictionary for mapping RIS
            for i in lst_resistant:
                d_ast[i] = "R"
            for i in lst_intermediate:
                d_ast[i] = "I"
            for i in lst_susceptible:
                d_ast[i] = "S"
            #Mapping blood, spctype,culture
            micro_1 = micro_0.copy()
            micro_1["mapped_blood"] = micro_1[spctype].map(d_blood).fillna("non-blood").astype("category") 
            micro_1["mapped_spctype"] = micro_1[spctype].map(d_allspc).fillna("unknown").astype("category") 
            micro_1["mapped_culture"] = micro_1[organism].map(d_no_growth).fillna("positive").astype("category") 
            # micro_1["mapped_blood"] = micro_1[spctype].map(d_blood).fillna("non-blood")
            # micro_1["mapped_spctype"] = micro_1[spctype].map(d_allspc).fillna("unknown")
            # micro_1["mapped_culture"] = micro_1[organism].map(d_no_growth).fillna("positive")
            ALB.sub_printprocmem("ANNEX B Mapping blood, specimen types",logger)
            micro_1 = ALB.map_ast_result(micro_1, df_drug, d_ast)
            ALB.sub_printprocmem("ANNEX B Mapping antibiotics",logger)
            
            micro_pos = micro_1.copy().loc[micro_1["mapped_culture"]=="positive",:].reset_index().drop(columns=["index"]) #dataframe with possitive cultures
            micro_pos = ALB.map_fam_org_gen_name(micro_pos, organism, dict_org_fam, dict_org_sci)
            nogrowth_status = len(micro_1.loc[micro_1["mapped_culture"]=="negative",:]) > 0 #nogrowth_status
            #Exporting Supplementary_data_indicators_overall.csv
            #Change in V3.0 to use the date convert with common lib, fn_cleandate function 
            #date = pd.to_datetime(micro_0[spcdate])
            date = micro_0[CLEANSPECDATE]
            #-----------------------------------------------------------------------------
            maximum_date = date.max().strftime("%d %b %Y")
            minimum_date = date.min().strftime("%d %b %Y")
            hospital_name = dict_micro.loc[dict_micro["amass_name"]=="hospital_name","user_name"].tolist()[0]
            hospital_country = dict_micro.loc[dict_micro["amass_name"]=="country","user_name"].tolist()[0]
            #overall = pd.DataFrame(columns=["Type_of_data_file","Parameters","Values"])
            temp_list = [["microbiology_data","Hospital_name",hospital_name], 
                         ["microbiology_data","Country",hospital_country], 
                         ["microbiology_data","Minimum_date",minimum_date], 
                         ["microbiology_data","Maximum_date",maximum_date], 
                         ["microbiology_data","Number_of_records",len(micro_0)], 
                         ["microbiology_data","Number_of_all_cultue_positive",len(micro_pos)], 
                         ["microbiology_data","Number_of_blood_specimens_collected",len(micro_1.loc[micro_1["mapped_blood"]=="blood"])], 
                         ["microbiology_data","Number_of_blood_culture_positive",len(micro_pos.loc[micro_pos["mapped_blood"]=="blood"])], 
                         ["microbiology_data","Number_of_blood_culture_negative",len(micro_1.loc[(micro_1["mapped_culture"]=="negative")&(micro_1["mapped_blood"]=="blood")])]]
            overall = pd.DataFrame(temp_list, columns =["Type_of_data_file","Parameters","Values"]) 
            overall.to_csv(AC.CONST_PATH_RESULT +"supplementary_data_indicators_results.csv",index=False)
            ##### RULE1 #####
            rule1 = datai_part2_2.copy().loc[datai_part2_2['rule_id']=="1",:] #filtering only rule1
            rule1 = ALB.assign_org_pocon(rule1)
            #### RULE2 #####
            rule2 = datai_part2_2.copy().loc[datai_part2_2['rule_id']=="2",:] #filtering only rule2
            rule2 = ALB.assign_drug_oth(micro_pos, rule2)
            #### RULE3a #####
            rule3a = datai_part2_2.copy().loc[datai_part2_2['rule_id']=="3a",:] #filtering only rule3a
            rule3a = ALB.assign_drug_oth(micro_pos, rule3a)
            #### RULE3b #####
            rule3b = datai_part2_2.copy().loc[datai_part2_2['rule_id']=="3b",:] #filtering only rule2
            rule3b = ALB.assign_drug_oth(micro_pos, rule3b)
            #Retrieving df which have to process for each rule
            idx_micro_rule1 = ALB.retrieve_idx_basedon_spc(micro_pos, rule1)
            idx_micro_rule2 = ALB.retrieve_idx_basedon_org(micro_pos, rule2)
            idx_micro_rule3a = ALB.retrieve_idx_basedon_org(micro_pos, rule3a)
            idx_micro_rule3b = ALB.retrieve_idx_basedon_org(micro_pos, rule3b)
            #Retrieving df of raw set of indicators
            rule1_export = datai_part2_export.loc[datai_part2_export['rule_id']=="1",:]
            rule2_export = datai_part2_export.loc[datai_part2_export['rule_id']=="2",:]
            rule3a_export = datai_part2_export.loc[datai_part2_export['rule_id']=="3a",:]
            rule3b_export = datai_part2_export.loc[datai_part2_export['rule_id']=="3b",:]
            #Deleting noused dataframes
            del [[micro_0, dict_org_fam, dict_org_sci]]
            del d_blood, d_no_growth, d_allspc, d_ast
            gc.collect()
            micro_0 = pd.DataFrame()
            dict_org_fam = pd.DataFrame()
            dict_org_sci = pd.DataFrame()
        except Exception as e:
            #logger.exception(e)
            AL.printlog("Error, ANNEX B microbiology_data file loading: " +  str(e),True,logger)
            pass
        AL.printlog("ANNEX B prepare antibiotic group",False,logger)
        try:
            lst_3gc = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_class"]=="3GC","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            lst_car = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_class"]=="Carbapenems","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            lst_flu = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_class"]=="Fluoroquinolones","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            #Penicillins; (Ampicillin_and_sulbactam=S) AND (Piperacillin_and_tazobactam=NS OR Ticarcillin_and_clavulanic_acid=NS)
            lst_asu = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_drug"]=="Ampicillin_and_sulbactam","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            lst_com = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[(df_drug["amass_drug"]=="Piperacillin_and_tazobactam")|(df_drug["amass_drug"]=="Ticarcillin_and_clavulanic_acid"),"amass_drug_rename"].tolist(),
                                        lst_micro_col= micro_pos.columns.tolist())
            #Penicillins and betalactam combinations; (betalactam combinations=NS) AND (PEN=S)
            lst_pen = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_class"]=="Penicillins","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            lst_betcom = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_class"]=="Betalactam_combinations","amass_drug_rename"].tolist(),
                                        lst_micro_col= micro_pos.columns.tolist())
            #Quinolones, Fluoroquinolones; (Nalidixic_acid=S) AND (Fluoroquinolones=NS)
            lst_qui = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_drug"]=="Nalidixic_acid","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            lst_flu = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_class"]=="Fluoroquinolones","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            #Cephems; (1GC=S OR 2GC=S) AND (3GC=NS)
            lst_gc = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[(df_drug["amass_class"]=="1GC")|(df_drug["amass_class"]=="2GC"),"amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            lst_3gc = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_class"]=="3GC","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            #Aminoglycoside; (AMK=NS) AND (GEN=S OR TOB=S OR NET=S)
            lst_amk = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[df_drug["amass_drug"]=="Amikacin","amass_drug_rename"].tolist(),
                                    lst_micro_col= micro_pos.columns.tolist())
            lst_othami = ALB.select_ava_drug(lst_qc_drug  = df_drug.loc[(df_drug["amass_drug"]=="Gentamicin")|(df_drug["amass_drug"]=="Tobramycin")|(df_drug["amass_drug"]=="Netilmicin"),"amass_drug_rename"].tolist(),
                                        lst_micro_col= micro_pos.columns.tolist())
            
    
            micro_data = ALB.retrieve_record_basedon_spc(df=micro_pos, lst_spc=list(set(rule1["antibiotic"])) + ["blood_specimen"])
            print ("Total positive samples tested with indicator: " + str(len(micro_data)))
            micro_data[["warning_indicator_1","priority_indicator_1","status_indicator_1",
                    "warning_indicator_2","priority_indicator_2","status_indicator_2","antibiotic_indicator_2",
                    "warning_indicator_3a","priority_indicator_3a","status_indicator_3a","antibiotic_indicator_3a",
                    "warning_indicator_3b","priority_indicator_3b","status_indicator_3b","antibiotic_indicator_3b"]] = ""
            micro_data[["car_3gc", "flu_3gc"]] = 0
            temp_idx = 0
            temp_df = pd.DataFrame(columns=micro_data.columns)
            count = 0
            for idx_mi in micro_data.index:
                ##### RULE1 #####
                if idx_mi in idx_micro_rule1 and nogrowth_status:
                    for idx_qc in rule1.index:
                        boolean_warning = ALB.check_blocon(qc_ge=rule1.loc[idx_qc,"rule_ge"], 
                                                        qc_ex=rule1.loc[idx_qc,"except_sp"], 
                                                        qc_in=rule1.loc[idx_qc,"include_sp"], 
                                                        qc_spc=rule1.loc[idx_qc,"antibiotic"].replace("_specimen",""), 
                                                        mi_sci=micro_data.loc[idx_mi,"mapped_sci"], 
                                                        mi_fam=micro_data.loc[idx_mi,"mapped_fam"], 
                                                        mi_spc=micro_data.loc[idx_mi,"mapped_spctype"])
                        # boolean_warning = check_blocon(qc_ge=rule1.loc[idx_qc,"rule_ge"], 
                        #                                 qc_ex=rule1.loc[idx_qc,"except_sp"], 
                        #                                 qc_spc=rule1.loc[idx_qc,"antibiotic"].replace("_specimen",""), 
                        #                                 mi_sci=micro_data.loc[idx_mi,"mapped_sci"], 
                        #                                 mi_fam=micro_data.loc[idx_mi,"mapped_fam"], 
                        #                                 mi_spc=micro_data.loc[idx_mi,"mapped_spctype"])
                        if boolean_warning is True: #If boolean_warning is True >>> do next process
                            micro_data.loc[idx_mi,"warning_indicator_1"] = "Possible contaminant" 
                            micro_data.loc[idx_mi,"priority_indicator_1"] = rule1.loc[idx_qc,"priority"]
                            micro_data.loc[idx_mi,"status_indicator_1"] = rule1.loc[idx_qc,"report_status"]
    
                ##### RULE2 #####
                if idx_mi in idx_micro_rule2:
                    rule2_sel = ALB.select_indicator_by_org_v2(micro_data, idx_mi, rule2)
                    for idx_qc in rule2_sel.index:
                        warning = ""
                        drug = rule2_sel.loc[idx_qc,"amass_drug_ava"]
                        lst_amr = micro_data.loc[idx_mi,drug].tolist()
                        boolean_warning = ALB.check_poerr_pathogen(tax_qc=rule2_sel.loc[idx_qc,"tax_level"], 
                                                            org_qc=rule2_sel.loc[idx_qc,"rule_organism"], 
                                                            fam_mi=micro_data.loc[idx_mi,"mapped_fam"], 
                                                            org_mi=micro_data.loc[idx_mi,"mapped_sci"], 
                                                            lst_amr=lst_amr, 
                                                            criteria="NS")
                        if boolean_warning is True: #If boolean_warning is True >>> do next process
                            micro_data.at[idx_mi,"priority_indicator_2"] = ALB.check_assign_priority(micro_data.loc[idx_mi,"priority_indicator_2"],rule2_sel.loc[idx_qc,"priority"])
                            micro_data.at[idx_mi,"status_indicator_2"] = ALB.check_assign_reportstatus(micro_data.loc[idx_mi,"status_indicator_2"],rule2_sel.loc[idx_qc,"report_status"])
                            warning = "; ".join([drug[i][:-8] + "=" + lst_amr[i] for i in range(len(lst_amr)) if lst_amr[i] != ""])
                            if micro_data.loc[idx_mi,"warning_indicator_2"] != "":
                                temp_df.loc[temp_idx,:] = micro_data.loc[idx_mi,:]
                                temp_df.at[temp_idx,"antibiotic_indicator_2"] = rule2_sel.loc[idx_qc,"antibiotic"]
                                temp_df.at[temp_idx,"warning_indicator_2"] = micro_data.loc[idx_mi,"mapped_sci"] + " isolate is resistant to " + rule2_sel.loc[idx_qc,"antibiotic"] + "markednewline(" + str(warning) +")"
                                temp_idx += 1
                            else:
                                micro_data.at[idx_mi,"antibiotic_indicator_2"] = rule2_sel.loc[idx_qc,"antibiotic"]
                                micro_data.at[idx_mi,"warning_indicator_2"] =  micro_data.loc[idx_mi,"mapped_sci"] + " isolate is resistant to " + rule2_sel.loc[idx_qc,"antibiotic"] + "markednewline(" + str(warning) +")"
    
                ##### RULE2-combination #####
                boolean_warning = False
                if micro_data.loc[idx_mi,"mapped_fam"] == "enterobacteriaceae":
                    boolean_warning = ALB.check_disast_fixS(lst_amr_NS = micro_data.loc[idx_mi,lst_3gc].tolist(),
                                                        lst_amr_S = micro_data.loc[idx_mi,lst_car].tolist())
                    if boolean_warning is True:
                        micro_data.at[idx_mi,"car_3gc"] = 1
                    else:
                        pass
                elif micro_data.loc[idx_mi,"mapped_sci"] == "neisseria gonorrhoeae":
                    boolean_warning = ALB.check_disast_fixS(lst_amr_NS = micro_data.loc[idx_mi,lst_flu].tolist(),
                                                        lst_amr_S = micro_data.loc[idx_mi,lst_3gc].tolist())
                    if boolean_warning is True:
                        micro_data.at[idx_mi,"flu_3gc"] = 1
                    else:
                        pass
    
                ##### RULE3a #####
                if idx_mi in idx_micro_rule3a:
                    boolean_warning = False
                    rule3a_sel = ALB.select_indicator_by_org_v2(micro_data, idx_mi, rule3a)
                    for idx_qc in rule3a_sel.index:
                        warning = ""
                        drug = rule3a_sel.loc[idx_qc,"amass_drug_ava"]
                        lst_amr = micro_data.loc[idx_mi,drug].tolist()
                        boolean_warning = ALB.check_poerr_pathogen(tax_qc=rule3a_sel.loc[idx_qc,"tax_level"], 
                                                            org_qc=rule3a_sel.loc[idx_qc,"rule_organism"], 
                                                            fam_mi=micro_data.loc[idx_mi,"mapped_fam"], 
                                                            org_mi=micro_data.loc[idx_mi,"mapped_sci"], 
                                                            lst_amr=lst_amr,  
                                                            criteria="S")
                        if boolean_warning is True: #If result_warn is True >>> do next process
                            micro_data.at[idx_mi,"priority_indicator_3a"] = ALB.check_assign_priority(micro_data.loc[idx_mi,"priority_indicator_3a"],rule3a_sel.loc[idx_qc,"priority"])
                            micro_data.at[idx_mi,"status_indicator_3a"] = ALB.check_assign_reportstatus(micro_data.loc[idx_mi,"status_indicator_3a"],rule3a_sel.loc[idx_qc,"report_status"])
                            warning = "; ".join([drug[i][:-8] + "=" + lst_amr[i] for i in range(len(lst_amr)) if lst_amr[i] != ""])
                            if micro_data.loc[idx_mi,"warning_indicator_3a"] != "":
                                temp_df.loc[temp_idx,:] = micro_data.loc[idx_mi,:]
                                temp_df.at[temp_idx,"antibiotic_indicator_3a"] = rule3a_sel.loc[idx_qc,"antibiotic"]
                                temp_df.at[temp_idx,"warning_indicator_3a"] = "Most " + micro_data.loc[idx_mi,"mapped_sci"] + " is intrinsically resistant to " + rule3a_sel.loc[idx_qc,"antibiotic"] + " and this isolate is reported as susceptible to " + rule3a_sel.loc[idx_qc,"antibiotic"] + "markednewline(" + str(warning) +")"
                                temp_idx += 1
                            else:
                                micro_data.at[idx_mi,"antibiotic_indicator_3a"] = rule3a_sel.loc[idx_qc,"antibiotic"]
                                micro_data.at[idx_mi,"warning_indicator_3a"] = "Most " + micro_data.loc[idx_mi,"mapped_sci"] + " is intrinsically resistant to " + rule3a_sel.loc[idx_qc,"antibiotic"] + " and this isolate is reported as susceptible to " + rule3a_sel.loc[idx_qc,"antibiotic"] + "markednewline(" + str(warning) +")"
    
                ##### RULE3b #####  
                if idx_mi in idx_micro_rule3b:
                    rule3b_sel = ALB.select_indicator_by_org_v2(micro_data, idx_mi, rule3b)
                    for idx_qc in rule3b_sel.index:
                        warning = ""
                        drug = rule3b_sel.loc[idx_qc,"amass_drug_ava"]
                        lst_amr = micro_data.loc[idx_mi,drug].tolist()
                        lst_amr_unique = list(set(micro_data.loc[idx_mi,drug].tolist()))
                        boolean_warning = False
                        #Penicillins and betalactam combinations; (betalactam combinations=NS) AND (PEN=S)
                        if rule3b_sel.loc[idx_qc,"tax_level"] == "all" and (rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="penicillins, betalactam_combinations" or rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="penicillins,betalactam_combinations" or rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="betalactam_combinations, penicillins" or rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="betalactam_combinations,penicillins"):
                            boolean_warning = ALB.check_disast_fixS(lst_amr_S=micro_data.loc[idx_mi,lst_pen].tolist(), 
                                                                lst_amr_NS=micro_data.loc[idx_mi,lst_betcom].tolist())
                        #Penicillins; (Ampicillin_and_sulbactam=S) AND (Piperacillin_and_tazobactam=NS OR Ticarcillin_and_clavulanic_acid=NS)
                        elif rule3b_sel.loc[idx_qc,"tax_level"] == "all" and (rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="penicillins"):
                            boolean_warning = ALB.check_disast_fixS(lst_amr_S=micro_data.loc[idx_mi,lst_asu].tolist(), 
                                                                lst_amr_NS=micro_data.loc[idx_mi,lst_com].tolist())
                        #Quinolones, Fluoroquinolones; (Nalidixic_acid=S) AND (Fluoroquinolones=NS)
                        elif rule3b_sel.loc[idx_qc,"tax_level"] == "all" and (rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="quinolones, fluoroquinolones" or rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="quinolones,fluoroquinolones"):
                            boolean_warning = ALB.check_disast_fixS(lst_amr_S=micro_data.loc[idx_mi,lst_qui].tolist(), 
                                                                lst_amr_NS=micro_data.loc[idx_mi,lst_flu].tolist())
                        #Aminoglycoside; (AMK=NS) AND (GEN=S OR TOB=S OR NET=S)
                        elif rule3b_sel.loc[idx_qc,"tax_level"] == "family" and rule3b_sel.loc[idx_qc,"rule_organism"].lower() == "enterobacteriaceae" and rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="aminoglycosides":
                            boolean_warning = ALB.check_disast_fixS(lst_amr_S=micro_data.loc[idx_mi,lst_othami].tolist(), 
                                                                lst_amr_NS=micro_data.loc[idx_mi,lst_amk].tolist())
                        #Cephems; (1GC=S OR 2GC=S) AND (3GC=NS)
                        elif rule3b_sel.loc[idx_qc,"tax_level"] == "family" and rule3b_sel.loc[idx_qc,"rule_organism"].lower() == "enterobacteriaceae" and rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="cephems":
                            boolean_warning = ALB.check_disast_fixS(lst_amr_S=micro_data.loc[idx_mi,lst_gc].tolist(), 
                                                                lst_amr_NS=micro_data.loc[idx_mi,lst_3gc].tolist())
                        #Aminoglycoside; (AMK=NS) AND (GEN=S OR TOB=S OR NET=S)
                        elif rule3b_sel.loc[idx_qc,"tax_level"] == "organism" and rule3b_sel.loc[idx_qc,"rule_organism"].lower() == "pseudomonas aeruginosa" and rule3b_sel.loc[idx_qc,"antibiotic"].lower()=="aminoglycosides":
                            boolean_warning = ALB.check_disast_fixS(lst_amr_S=micro_data.loc[idx_mi,lst_othami].tolist(), 
                                                                lst_amr_NS=micro_data.loc[idx_mi,lst_amk].tolist())
                        else: #other indicators
                            if len(lst_amr_unique) >= 2: 
                                boolean_warning = ALB.check_disast(tax_qc=rule3b_sel.loc[idx_qc,"tax_level"], 
                                                            org_qc=rule3b_sel.loc[idx_qc,"rule_organism"], 
                                                            fam_mi=micro_data.loc[idx_mi,"mapped_fam"], 
                                                            org_mi=micro_data.loc[idx_mi,"mapped_sci"], 
                                                            lst_antibiotic=lst_amr_unique) 
                            else:
                                pass
    
                        if boolean_warning is True: # if result_warn is True >>> do next process
                            micro_data.at[idx_mi,"priority_indicator_3b"] = ALB.check_assign_priority(micro_data.loc[idx_mi,"priority_indicator_3b"],rule3b_sel.loc[idx_qc,"priority"])
                            micro_data.at[idx_mi,"status_indicator_3b"] = ALB.check_assign_reportstatus(micro_data.loc[idx_mi,"status_indicator_3b"],rule3b_sel.loc[idx_qc,"report_status"])       
                            warning = "; ".join([drug[i][:-8] + "=" + lst_amr[i] for i in range(len(lst_amr)) if lst_amr[i] != ""])
                            if micro_data.loc[idx_mi,"warning_indicator_3b"] != "":
                                temp_df.loc[temp_idx,:] = micro_data.loc[idx_mi,:]
                                temp_df.at[temp_idx,"antibiotic_indicator_3b"] = rule3b_sel.loc[idx_qc,"antibiotic"]
                                temp_df.at[temp_idx,"warning_indicator_3b"] = "AST results of " + rule3b_sel.loc[idx_qc,"antibiotic"] + " of this " + micro_data.loc[idx_mi,"mapped_sci"] + " isolate are discordant" + "markednewline(" + str(warning) +")"
                                temp_idx += 1
                            else:
                                micro_data.at[idx_mi,"antibiotic_indicator_3b"] = rule3b_sel.loc[idx_qc,"antibiotic"]
                                micro_data.at[idx_mi,"warning_indicator_3b"] = "AST results of " + rule3b_sel.loc[idx_qc,"antibiotic"] + " of this " + micro_data.loc[idx_mi,"mapped_sci"] + " isolate are discordant" + "markednewline(" + str(warning) +")"
                count += 1
                ALB.print_round(count, len(micro_data))
            #micro_data_append = micro_data.append(temp_df, ignore_index = True)
            micro_data_append = pd.concat([micro_data,temp_df], ignore_index = True)
            #AL.fn_savexlsx(micro_data_append, AC.CONST_PATH_RESULT + "raw_annex_B.xlsx", logger)
            #Deleting noused dataframes
            del [[df_drug, datai_part2_2, temp_df]]
            del idx_micro_rule1, idx_micro_rule2, idx_micro_rule3a, idx_micro_rule3b
            gc.collect()
            datai_part2_2 = pd.DataFrame()
            temp_df = pd.DataFrame()
        except Exception as e:
            #logger.exception(e)
            AL.printlog("Error, ANNEX B antibiotic group preparing: " +  str(e),True,logger)
            pass
        AL.printlog("ANNEX B Exporting",False,logger)
        try:
            micro_blood = micro_data.copy().loc[micro_data["mapped_blood"]=="blood"]
            #Checking AST data and selecting only records with at least 1 AST data
            micro_blood = ALB.check_ast_records(df = micro_blood, 
                                            col_ast = "check_AST", 
                                            str_ast_found = "Y", 
                                            str_ast_notfound = "N")
            micro_blood_ast = micro_blood.loc[micro_blood["check_AST"]=="Y"]
            #Creating dataframe combines with positive and negative blood specimen (edited 02/11/21)
            micro_blood_neg = micro_1.loc[(micro_1["mapped_blood"]=="blood")&
                                        (micro_1["mapped_culture"]=="negative"),:] #nogrowth for blood
            micro_blood_pos_neg = pd.concat([micro_blood_neg,micro_blood], axis=0) #merging nogrowth + positive for blood
            #Exporting AC.CONST_FILENAME_secB_blo_i
            try:
                annex_blood = ALB.create_assign_annex_v2(micro_blood)
                annex_blood = annex_blood.rename(index={"indicator_1":"blood_contamination", 
                                                        "indicator_2":"antibiotic_pathogen_combinations",
                                                        "indicator_3":"potential_errors"})
                annex_csv = ALB.export_annexB(df = annex_blood, 
                                        nogrowth_status = nogrowth_status,
                                        df_blo_posneg = micro_blood_pos_neg, 
                                        df_blo_ast    = micro_blood_ast, 
                                        rule1  = rule1, 
                                        rule2  = rule2, 
                                        rule3a = rule3a, 
                                        rule3b = rule3b)
                annex_csv.to_csv(o_tab_blo,index=False,header=True)
                AL.printlog("Start generate annex B result data file compatible with AMASS V2.0: ",False,logger)
                try:
                    annex_csv.to_csv(v2_o_tab_blo,index=False,header=True)
                except Exception as e:
                    AL.printlog("Fail generate annex B result data file compatible with AMASS V2.0: " +  str(e),True,logger) 
                    logger.exception(e)
            except Exception as e:
                AL.printlog("Warning : ANNEX B Exporting (S1): " + str(e),False,logger)
                pass
            #Exporting AC.CONST_FILENAME_secB_blo_mon_i
            try:
                #Change in V3.0 to use the date convert with common lib, fn_cleandate function 
                """
                micro_blo_bymonth = ALB.create_assign_annexB_bymonth(df = micro_blood, 
                                                                df_blo_posneg = micro_blood_pos_neg, 
                                                                df_blo_ast    = micro_blood_ast, 
                                                                col_spcdate   = spcdate)
                """
                micro_blo_bymonth = ALB.create_assign_annexB_bymonth(df = micro_blood, 
                                                                df_blo_posneg = micro_blood_pos_neg, 
                                                                df_blo_ast    = micro_blood_ast, 
                                                                col_spcdate   = CLEANSPECDATE)
                #------------------------------------------------------------------------------
                micro_blo_bymonth = ALB.export_annexB_bymonth(df = micro_blo_bymonth, nogrowth_status = nogrowth_status)
                micro_blo_bymonth.to_csv(o_tab_blo_bymonth,index=True,header=True)
                try:
                    micro_blo_bymonth.to_csv(v2_o_tab_blo_bymonth,index=True,header=True)
                except Exception as e:
                    AL.printlog("Fail generate annex B result data file compatible with AMASS V2.0: " +  str(e),True,logger) 
                    logger.exception(e)
            except Exception as e:
                AL.printlog("Warning : ANNEX B Exporting (S2): " + str(e),False,logger)
                pass
            #creating summary table for indicators
            #indicator_1
            try:
                rule1_export_1 = ALB.create_summary_table_supp_pocon_v2(nogrowth_status,rule1_export,micro_data_append.loc[(micro_data_append["mapped_blood"]=="blood")&(micro_data_append["warning_indicator_1"]!=""),:],int_denominator=len(micro_blood_pos_neg))
                rule1_export_1.to_excel(AC.CONST_PATH_RESULT+ "Supplementary_data_indicators_indicator1.xlsx",index=False,header=True)
            except Exception as e:
                AL.printlog("Warning : ANNEX B Exporting (S3): " + str(e),False,logger)
                pass
            #indicator_2
            try:
                rule2_export_1 = ALB.create_summary_table_supp_poerr_v2(df_qc=rule2_export,df_mi=micro_data_append.loc[micro_data_append["mapped_blood"]=="blood"],int_denominator=len(micro_blood_ast), col_mi_drug="antibiotic_indicator_2")
                rule2_export_2 = rule2_export_1.copy()
                rule2_export_2["antibiotic"] = rule2_export_2["antibiotic"] + "-NS"
                #indicator_2: Carbapenem-S and 3GC-NS
                num_car_3gc = len(micro_data_append.loc[micro_data_append["car_3gc"]==1])
                per_car_3gc = ALB.cal_perc_annex_v1(num_car_3gc,len(micro_blood_ast)) + " (" + str(num_car_3gc) + "/" + str(len(micro_blood_ast)) + ")"
                df_car_3gc = pd.DataFrame([["Enterobacteriaceae","Carbapenem-S and 3GC-NS",per_car_3gc]], columns = rule2_export_1.columns)
                #indicator_2: Fluoroquinolones-NS and 3GC-S
                num_flu_3gc = len(micro_data_append.loc[micro_data_append["flu_3gc"]==1])
                per_flu_3gc = ALB.cal_perc_annex_v1(num_flu_3gc,len(micro_blood_ast)) + " (" + str(num_flu_3gc) + "/" + str(len(micro_blood_ast)) + ")"
                df_flu_3gc = pd.DataFrame([["Neisseria gonorrhoeae","Fluoroquinolones-NS and 3GC-S",per_flu_3gc]], columns = rule2_export_1.columns)
                #indicator_2: merging
                rule2_export_3 = pd.concat([rule2_export_2.loc[:3,:], df_car_3gc, rule2_export_2.loc[4:11,:], df_flu_3gc]).reset_index().drop(columns=["index"])
                rule2_export_3["blood_samples"] = rule2_export_3["blood_samples"].replace("NA (0/0)","NA")
                rule2_export_3.to_excel(AC.CONST_PATH_RESULT+ "Supplementary_data_indicators_indicator2.xlsx",index=False,header=True)
            except Exception as e:
                AL.printlog("Warning : ANNEX B Exporting (S4): " + str(e),False,logger)
                pass
            #indicator_3a and 3b
            try:
                rule3a_export_1 = ALB.create_summary_table_supp_poerr_v2(df_qc=rule3a_export,df_mi=micro_data_append.loc[micro_data_append["mapped_blood"]=="blood"],int_denominator=len(micro_blood_ast), col_mi_drug="antibiotic_indicator_3a")
                rule3a_export_1["blood_samples"] = rule3a_export_1["blood_samples"].replace("NA (0/0)","NA")
                rule3a_export_1.to_excel(AC.CONST_PATH_RESULT+ "Supplementary_data_indicators_indicator3a.xlsx",index=False,header=True)
            except Exception as e:
                AL.printlog("Warning : ANNEX B Exporting (S5): " + str(e),False,logger)
                pass
            try:
                rule3b_export_1 = ALB.create_summary_table_supp_poerr_v2(df_qc=rule3b_export,df_mi=micro_data_append.loc[micro_data_append["mapped_blood"]=="blood"],int_denominator=len(micro_blood_ast), col_mi_drug="antibiotic_indicator_3b")
                rule3b_export_1["blood_samples"] = rule3b_export_1["blood_samples"].replace("NA (0/0)","NA")
                rule3b_export_1.to_excel(AC.CONST_PATH_RESULT+ "Supplementary_data_indicators_indicator3b.xlsx",index=False,header=True)
            except Exception as e:
                AL.printlog("Warning : ANNEX B Exporting (S6): " + str(e),False,logger)
                pass
    
            #Deleting noused dataframes
            del [[micro_1, micro_blood_neg, annex_blood, annex_csv, micro_blo_bymonth, micro_blood_pos_neg, micro_blood_ast, rule1, rule2, rule3a, rule3b]]
            gc.collect()
            micro_1 = pd.DataFrame()
            micro_blood_neg = pd.DataFrame()
            annex_blood = pd.DataFrame()
            annex_csv   = pd.DataFrame()
            micro_blo_bymonth = pd.DataFrame()
            micro_blood_pos_neg = pd.DataFrame()
            micro_blood_ast = pd.DataFrame()
            rule_1  = pd.DataFrame()
            rule_2  = pd.DataFrame()
            rule_3a = pd.DataFrame()
            rule_3b = pd.DataFrame()
        except Exception as e:
            #logger.exception(e)
            AL.printlog("Error, Exporting: " +  str(e),True,logger)
            pass
        
        try:
            #Selecting dataframe containing only warning records
            micro_onlywarning = ALB.retrieve_recordbywarning(micro_data_append)
            #Change in V3.0 to use the date convert with common lib, fn_cleandate function 
            """
            if (spcnum == "") or (spcnum not in micro_onlywarning.columns): #If there is no available specimen_nember column >>> create specimen_column from index
                micro_onlywarning = ALB.create_columncombine(df=micro_onlywarning,hn=hn,date=spcdate,type_=spctype,num="mapped_specimen_number",org=organism)
            else:
                micro_onlywarning = ALB.create_columncombine(df=micro_onlywarning,hn=hn,date=spcdate,type_=spctype,num=spcnum,org=organism)
            if (bisusingmappeddata == True) or (fmt == "wide"):
                ALB.export_records_withwarning_wide(df = micro_onlywarning,
                                            dict_datai = d_datai_part1,
                                            str_filename_withstatus    = o_list_withstatus, 
                                            str_filename_withoutstatus = o_list_withoutstatus, 
                                            col_hn = hn, 
                                            col_spcdate = spcdate,
                                            col_spcnum  = spcnum)
            else:
                ALB.export_records_withwarning_long(df = micro_onlywarning,
                                                dict_datai = d_datai_part1,
                                                str_filename_rawmicro = path + f_micro +".xlsx",
                                                str_filename_withstatus    = o_list_withstatus, 
                                                str_filename_withoutstatus = o_list_withoutstatus, 
                                                col_hn=hn,
                                                col_spcdate=spcdate,
                                                col_spctype=spctype,
                                                col_organism=organism,
                                                col_spcnum  = spcnum)
            """
            stmp = "mapped_specimen_number" if (spcnum == "") or (spcnum not in micro_onlywarning.columns) else spcnum
            micro_onlywarning = ALB.create_columncombine(df=micro_onlywarning,hn=hn,date=CLEANSPECDATE,type_=spctype,num=stmp,org=organism)
            if (bisusingmappeddata == True) or (fmt == "wide"):
                ALB.export_records_withwarning_wide(df = micro_onlywarning,
                                            dict_datai = d_datai_part1,
                                            str_filename_withstatus    = o_list_withstatus, 
                                            str_filename_withoutstatus = o_list_withoutstatus, 
                                            col_hn = hn, 
                                            col_spcdate = CLEANSPECDATE,
                                            col_spcnum  = spcnum)
            else:
                ALB.export_records_withwarning_long(df = micro_onlywarning,
                                                dict_datai = d_datai_part1,
                                                str_filename_rawmicro = path + f_micro +".xlsx",
                                                str_filename_withstatus    = o_list_withstatus, 
                                                str_filename_withoutstatus = o_list_withoutstatus, 
                                                col_hn=hn,
                                                col_spcdate=CLEANSPECDATE,
                                                col_spctype=spctype,
                                                col_organism=organism,
                                                col_spcnum  = spcnum)
             #------------------------------------------------------------------
            #Deleting noused dataframes
            del [[micro_onlywarning]]
            gc.collect()
            micro_onlywarning = pd.DataFrame()
        except Exception as e:
            logger.exception(e)
            pass
    else:
        pass
    
    if ALB.check_config(config, "amr_surveillance_function"):
        try:
            #Change in V3.0 to use the date convert with common lib, fn_cleandate function 
            """
            ALB.export_records_annexA(df = micro_pos, 
                                dictionary = dict_micro, 
                                col_spcdate = spcdate, 
                                col_organism = organism)
            """
            ALB.export_records_annexA(df = micro_pos, 
                                dictionary = dict_micro, 
                                col_spcdate = CLEANSPECDATE, 
                                col_organism = organism)
            #Deleting not used dataframes
            del [[micro_pos]]
            gc.collect()
            micro_pos = pd.DataFrame()
        except Exception as e:
            logger.exception(e)
            pass
    else:
        pass
    AL.printlog("ANNEX B Completed on "+ str(datetime.datetime.now()),False,logger)
